#!/usr/bin/env python

"""
Simulate multi-object spectrograph CCD images given input spectra and PSF

Stephen Bailey, LBL
Fall 2012
"""

import sys
import os
import numpy as N
import optparse
from specter.psf import load_psf
from specter.throughput import load_throughput
import fitsio

parser = optparse.OptionParser(
    usage = "%prog [options]",
    epilog = "See $SPECTER_DIR/doc/datamodel.md for input format details"
    )
parser.add_option("-i", "--input", type="string",  help="input spectra")
parser.add_option("-o", "--output", type="string",  help="output image")
parser.add_option("-p", "--psf", type="string",  help="input PSF")
parser.add_option("-t", "--throughput", type="string",  help="input throughput file")
parser.add_option("-n", "--noise", action="store_true", help="add noise")
parser.add_option("-N", "--readnoise", type="float", default=4.0, help="readout noise in electrons [%default]")
parser.add_option(      "--randseed", type="int", default=0, help="random number seed")
parser.add_option("-G", "--gaussnoise", action='store_true', help="Use Gaussian photon shot noise instead of Poisson")
parser.add_option("-g", "--gain", type="float", default=1.6, help="CCD gain [%default]")

### parser.add_option("-s", "--sky", type="string",  help="input sky spectra")
parser.add_option("-w", "--wavelength", type="string",
    help="wavelength range min,max in Angstroms")
parser.add_option("-l", "--loglam", type="string",
    help="log10(wavelength[A]) range min,max")
parser.add_option("-r", "--specrange", type="string",
    help="range of spectra to simulate specmin,specmax")
parser.add_option("--debug", action="store_true", help="start ipython after running")

opts, args = parser.parse_args()

#+ TODO: Test input consistency
#- required: --input, --output, --psf
#- exclusive: --wavelength or --loglam or neither, but not both

#- Ensure reproducibility
N.random.seed(opts.randseed)

#- Load inputs
psf = load_psf(opts.psf)
if opts.throughput:
    thru = load_throughput(opts.throughput)
else:
    thru = load_throughput(opts.psf)
    
spectra = fitsio.read(opts.input, 1, lower=True).view(N.recarray)
header = fitsio.read_header(opts.input, 1)

#- Expand defaults
if opts.specrange is not None:
    x = map(int, opts.specrange.split(','))
    x[1] = min(x[1]+1, psf.nspec)
    opts.specrange = range(x[0], x[1])
else:
    opts.specrange = range(psf.nspec)

#- Wavelength and loglam are just 2-elements min,max
if opts.wavelength is not None:
    opts.wavelength = map(float, opts.wavelength.split(','))
    opts.loglam = N.log10(opts.wavelength)
elif opts.loglam is not None:
    opts.loglam = map(float, opts.loglam.split(','))
    opts.wavelength = 10**opts.loglam
else:
    ll = psf.loglam()
    opts.loglam = N.array( [N.min(ll), N.max(ll)] )
    opts.wavelength = 10**opts.loglam
    
#- Get flux and wavelength arrays
wavelength = spectra['wavelength']
flux = spectra['flux']

#- Determine flux units from TUNITnn or FLUXUNIT keywords
key = 'TUNIT%d' % (spectra.dtype.names.index('flux')+1, )
if key in header:
    units = header[key].strip()
elif 'FLUXUNIT' in header:
    units = header['FLUXUNIT'].strip()
else:
    print >> sys.stderr, 'WARNING: using default flux units of erg/s/cm^2/A'
    units = 'erg/s/cm^2/A'

#- Make array of object types
if 'objtype' in spectra.dtype.names:
    objtype = spectra['objtype']
elif 'OBJTYPE' in header:
    objtype = N.array( [header['OBJTYPE'].strip(), ] * psf.nspec )

#- Convert 1D flux into 2D
if flux.ndim == 1:
    photons = thru.photons(wavelength, flux, units, objtype=objtype[0])
    photons = N.tile(photons, psf.nspec).reshape(psf.nspec, len(flux))
else:
    photons = N.zeros(flux.shape)
    for i in range(photons.shape[0]):
        photons[i] = thru.photons(wavelength, flux[i], units, objtype=objtype[i])

#- Trim to just requested specrange
photons = photons[opts.specrange]
if wavelength.ndim == 2:
    wavelength = wavelength[opts.specrange]

#- Trim wavelength range by setting photons=0 outside wavelength range
wmin, wmax = opts.wavelength
if wavelength.ndim == 1:
    ii = (wmin <= wavelength) & (wavelength <= wmax)
    photons = photons[:, ii]
    wavelength = wavelength[ii]
else:
    #- for 2D, just set photons=0 outside wavelength range
    ii = (wavelength < wmin) | (wmax < wavelength)
    photons[ii] = 0.0

#- Do the projection
#+ TODO: Add options for simulating xy subregion
img = psf.project(photons, wavelength, specmin=opts.specrange[0])

#- Add shot noise
var = opts.readnoise**2 + img
if opts.gaussnoise:
    opts.noise = True

if opts.noise:
    if opts.gaussnoise:
        print "Adding only gaussian noise"
        img += N.random.normal(scale=N.sqrt(var))
    else:
        #- photon shot noise (float -> int)
        img = N.random.poisson(img)
        
        #- Convert to ADU, add gaussian read noise, then integerize
        img /= opts.gain
        img += N.random.normal(scale=opts.readnoise/opts.gain, size=img.shape)
        img = (img+0.5).astype(int)

        #- Convert back to photons (back to a float)
        img = img * opts.gain
        
#- Write output
fitsio.write(opts.output, img, clobber=True)

#- Update header keywords
fx = fitsio.FITS(opts.output, 'rw')
fx[0].write_key('SIMDATA', True, 'Simulated image written by specter')
fx[0].write_key('PREPROC', True, 'Preproc done (1/0 = True/False)')
fx[0].write_key('GAIN', opts.gain, 'Gain [e-/ADU]')
fx[0].write_key('RDNOISE', opts.readnoise, 'Read noise [e-]')

if opts.gaussnoise:
    fx[0].write_key('SIMNOISE', 'Gaussian', 'Gaussian noise (not Poisson)')
    fx[0].write_key('RDNOISE', opts.readnoise, 'Read noise [e-]')    
elif opts.noise:
    fx[0].write_key('SIMNOISE', 'Poisson', 'Poisson photon noise + Gaussian read noise')
    fx[0].write_key('RDNOISE', opts.readnoise, 'Read noise [e-]')    
else:
    fx[0].write_key('SIMNOISE', 'None', 'No noise (cant you tell?)')
    fx[0].write_key('RDNOISE', 0.0, 'No read noise added')    

fx.close()

#- Add IVAR HDU if noise was added
if opts.noise:
    fitsio.write(opts.output, 1.0/var, extname='IVAR')

#+ TODO: Add options to add other types of extra info

if opts.debug:
    #--- DEBUG ---
    import IPython
    IPython.embed()
    #--- DEBUG ---
    
